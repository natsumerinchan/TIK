# 打包
function packmenu()
{
clear
if [[ -f "./dynamic_partitions_op_list" ]] || [ -d "./payload" ] || [ -d "./super" ] ;then
	dynam=1
else
	if [ $version -lt 10 ];then
	dynam=0
	else
		read -p "工具无法判断。是否为动态分区?[y/n]" dycheck </dev/tty
		if [ "$dycheck" != "n" ];then
			dynam=1
		else
			dynam=0
		fi
	fi
fi
cd $LOCALDIR && cd $project
echo 修复项目文件权限...
sudo chmod -R 777 $PROJECT_DIR
clear
echo  
echo -e "\033[33m 	<-打包菜单 \033[0m" 
echo "	--------------------------------"
echo " 	1 > 返回 hom       2 > 打包 Bro " 
echo " 	3 > 打包 Dat       4 > 打包 Img " 
echo " 	5 > 打包 Super " 
#echo " 		  5 > 打包 DTBO        8 > 打包 DTB"
echo " 	--------------------------------" 
if [ "$new" == "1" ]; then
echo -e "\033[32m 新用户提醒：“打包img”这一项会自动打包boot/recovery/vendor_boot等可启动分区以及system/vendor等分区，不包含dtbo,logo等 \033[0m" 
echo -e "\033[32m 	系统分区的打包流程是三步，打包img->打包dat->打包bro \033[0m" 
echo -e "\033[32m 	当您直接选择"打包bro","打包dat"时，会自动帮您补全缺少的流程\033[0m" 
echo -e "\033[32m 	对于动态分区，工具会自动更改刷写脚本，避免因大小改变无法刷入的情况\033[0m" 
echo -e "\033[32m 	即使您忘记打包某些必要分区，工具最终生成rom时依然会提醒您！\033[0m" 
fi
read -p "	请输入编号: " op_menu
case $op_menu in
        1)
        menu
        ;;
		2)
		if [ "$dynam" = "1" ];then
        packbrdy
		else
		packbrst
		fi
        ;;
		3)
		if [ "$dynam" = "1" ];then
        packdatdy
		else
		packdatst
		fi
        ;;
		4)
		if [ "$dynam" = "1" ];then
        packimgdy
		else
		packimgdy
		fi
		;;
		5)
		if [ "$dynam" = "1" ];then
        packsuper
		packmenu
		else
		echo 你不是动态分区 你不配
		sleep $sleeptime
		packmenu
		fi
		;;
		
        *)
#       echo -e "请输入正确编号"
        echo -e "本功能暂未开发！"
		sleep $sleeptime
        packmenu
esac
}

# 分解菜单
function unpmenu()
{
clear
cd $LOCALDIR && cd $project
echo -e "\033[33m 	<-分解菜单 \033[0m" 
echo "	----------------------------------"
echo " 	 1 > 返回 hom       2 > 分解 Bro " 
echo " 	 3 > 分解 Dat       4 > 分解 Img " 
echo " 	 5 > 分解 Bin       6 > 分解 Win "
echo " 	 7 > 分解 DTBO      8 > 分解 DTB"
echo " 	 9 > 分解 OFP       10> 分解 OZIP "
echo " 	 11 > 分解 LOGO     "
echo " 	--------------------------------- " 
if [ "$new" == "1" ]; then
echo -e "\033[32m新用户提醒：“分解bro”和“分解dat”最终解包到img，您可以继续选择“解包img” \033[0m" 
echo  
echo -e "\033[32m 	"[4]分解Img"仅用于分解ext4/erofs/super/启动镜像\033[0m" 
echo  
echo -e "\033[32m 	bin指payload.bin,win指TWRP备份出的ext4文件 \033[0m" 
fi
read -p "	请输入编号: " op_menu
case $op_menu in
        1)
        menu
        ;;
		2)
        unbr
        ;;
		3)
        undat
        ;;
		4)
        unimg
		unpmenu
        ;;
		7)
        undtbo
        ;;
		8)
        undtb
        ;;
		9)
        unofp
        ;;
        *)
#       echo -e "请输入正确编号"
        echo -e "本功能暂未开发！"
		sleep $sleeptime
        unpmenu
esac
}

# 主菜单2
function payloadmenu()
{
clear
cd $LOCALDIR && cd $project
echo -e "\033[33m	欢迎使用QualityTeam ROM一键解打包工具-V-AB专区 \033[0m"

echo "	当前项目：$project"
echo "	---------------------------------------------------"
echo -e "\033[31m 		  1> 主页[hom]      2> 分解[img] \033[0m" 
echo -e "\033[32m 		  3> 合成[img]      4> 插件[sub] \033[0m" 
echo -e "\033[33m 		  5> 一键制作V-AB专用线刷包 \033[0m"
echo -e "\033[35m 		  6> 一键刷入V-AB专用线刷包 \033[0m"
echo -e "\033[37m 	--------------------------------------- \033[0m" 
if [ "$new" == "1" ]; then
echo -e "\033[32m 	新用户提醒：自动解包或手动分解payload.bin后，工具将切换至V-AB机型特别适配页！ \033[0m" 
fi
read -p "	请输入编号: " op_menu
case $op_menu in
        1)
        promenu
        ;;
		2)
        unimg
		payloadmenu
        ;;
        *)
#       echo -e "请输入正确编号"
        echo -e "本功能暂未开发！"
		sleep $sleeptime
        payloadmenu
esac
}


# 解压img
function unimg()
{
clear
cd $LOCALDIR && cd $project
echo -e "\033[33m 	<-分解IMG \033[0m" 
if ls *.img >/dev/null 2>&1;then
	read -p "是否解压所有img [y/n]" imgall
	if [ "$imgall" != "y" ];then
	echo "跳过自动解压！"
	fi	
	read -p "是否解压后删除所有源img?[y/n]" imgdelall
	if [ "$imgdelall" != "y" ];then
	echo "解压后保留所有源img！"
	fi
	imglist=$(ls *.img)
	ls *.img | while read i; do
	sf=$(echo "$i" | cut -d"/" -f3| cut -d"." -f1)
	info=$(file $i)
		if [ "$imgall" = "y" ];then
			echo 解压 $i
			rm -fr ./TI_out/$i
			imgextra
		else
		read -p "是否解包$i?[y/n]" imgcheck </dev/tty
			if [ "$imgcheck" != "n" ];then
				echo 解压 $i
				rm -fr ./TI_out/$i
				imgextra
			fi
		fi
		if [ "$imgcheck" = "y" ];then
			if [ "$imgdelall" = "y" ];then
				rm -f $i
			else
				read -p "是否删除$i?[y/n]" imgdel </dev/tty
				if [ "$imgdel" = "y" ];then
					rm -f $i
				else
					echo "已跳过删除$i！"
				fi
			fi
		fi
	done
else
echo "	没有img文件！"
fi
unpmenu
}

function imgextra()
{
if [ "$sf" == "super" ];then
	lpunpack="$ebinner/lpunpack"
	if (file ./super.img | grep -qo "sparse") ;then
		echo "当前super.img转换为rimg中..."
		$ebinner/simg2img ./super.img ./superr.img
		rm -rf ./super.img
		mv ./superr.img ./super.img
		echo "转换完成"
	fi
	super_size=$(du -sb "./super.img" | awk '{print $1}' | bc -q)
	echo "super分区大小: $super_size bytes  解压super.img中..."
	mkdir super
	TARGETDIR=./super
	$lpunpack ./super.img $TARGETDIR
	if [ $? != "0" ];then
		echo "解压失败"
	else
		echo "super输出至 $TARGETDIR"
	fi
	touch ./TI_config/super
	chmod 777 -R $TARGETDIR
elif echo $info | grep "ext2" > /dev/null 2>&1; then
	sudo python3 $binner/imgextractor.py ./$i ./ > /dev/null
	rm -rf ./$sf.img
elif echo $info | grep "ext4" > /dev/null 2>&1; then
	sudo python3 $binner/imgextractor.py ./$i ./ > /dev/null
	rm -rf ./$sf.img
elif echo $info | grep "sparse" > /dev/null 2>&1; then
	sudo python3 $binner/imgextractor.py ./$i ./ > /dev/null
	rm -rf ./$sf.img
	rm -rf ./$sf.raw.img
elif echo $info | grep "bootimg" > /dev/null 2>&1 || [ "$sf" == "boot" ] || [ "$sf" == "vendor_boot" ] || [ "$sf" == "recovery" ] || [ "$sf" == "vendor_boot" ] || [ "$sf" == "recovery" ]; then
	sudo mkdir $sf
	sudo $AIK/unpackimg.sh ./$i > /dev/null
	mv $AIK/ramdisk ./$sf/
	mv $AIK/split_img ./$sf/
	chmod 777 -R ./$sf/
	touch ./TI_config/$i.boot
	echo "分解$i成功！"
else
	echo "正在尝试使用erofs解压"
	$ebinner/erofsUnpackKt $i ./
	if ! $ebinner/erofsUnpackKt $i ./ 2&>/dev/null ;then
		echo "$i解压失败！"
	fi
	mv ./config ./TI_config
fi
}

function bootpac()
{
echo "正在生成newp$sf.img..."
cp -afrv $PROJECT_DIR/$sf/* $AIK > /dev/null
$AIK/repackimg.sh --forceelf > /dev/null
if [ -e $AIK/unpadded-new.img ];then
  mv $AIK/unpadded-new.img $PROJECT_DIR/exaid/
fi
mv $AIK/image-new.img $AIK/$sf.img
mv $AIK/$sf.img $PROJECT_DIR/TI_out/
rm -rf $AIK/split_img
rm -rf $AIK/ramdisk
if [ -e $AIK/ramdisk-new.cpio.gz ]; then
  rm -rf $AIK/ramdisk-new.cpio.gz
fi
echo "生成完毕，输出至TI_out目录"
sleep $sleeptime
}


# 打包img
function packimgdy()
{
clear
cd $LOCALDIR && cd $project
echo -e "\033[33m 	<-打包IMG \033[0m" 
PROJECT_DIR=$LOCALDIR/$project
if [[ ! -d "TI_out" ]]; then
mkdir $PROJECT_DIR/TI_out
fi
if ls ./TI_config/*.boot >/dev/null 2>&1;then
	read -p "是否打包所有启动镜像？ [y/n]" pacall
	if [ "$pacall" != "y" ];then
	echo "跳过自动打包！"
	fi
	pacimglist=$(ls ./TI_config/*.boot)
	ls ./TI_config/*.boot | while read i; do
	sf=$(echo "$i" | cut -d"/" -f3| cut -d"." -f1)
	info=$(file $i)
	rm -rf $AIK/split_img
	rm -rf $AIK/ramdisk
	rm -rf $AIK/*.img
	if [ -e $AIK/ramdisk-new.cpio.gz ]; then
		rm -rf $AIK/ramdisk-new.cpio.gz
	fi
		if [ "$pacall" = "y" ];then
			echo 打包 $sf.img
			bootpac
		else
		read -p "是否打包$sf.img?[y/n]" imgcheck </dev/tty
			if [ "$imgcheck" != "n" ];then
				echo 打包 $sf.img
				bootpac
			fi
		fi
	done
fi
if ls ./TI_config/*_fs_config >/dev/null 2>&1;then
	read -p "是否打包所有系统镜像？ [y/n]" pacall
	if [ "$pacall" != "y" ];then
	echo "跳过自动打包！"
	fi
	read -p "打包文件系统?[1]ext4 [2]erofs" syscheck
	ls ./TI_config/*_fs_config | while read i; do
	sf=$(echo "$i" | cut -d"/" -f3 | rev | cut -d'_' -f1 --complement | cut -d'_' -f1 --complement | rev)
	part="$LOCALDIR/$project/$sf"
	zj=`du -sb $part | awk {'print $1'}`
	if [ $zj -gt 10000000 ] ; then
		dbzj=`echo "$zj * 1.0758" |bc`
	else
		dbzj=`echo "$zj * 1.2" |bc`  
	fi
	op=`echo $dbzj|sed 's/\..*//g'`
	echo $op >$PROJECT_DIR/TI_config/${sf}_size.txt
	sizes=`echo "$dbzj / 4096" |bc`
	if [[ -f "dynamic_partitions_op_list" ]]; then
	sed -i "s/resize ${sf}\s.*/resize ${sf} $op/" $PROJECT_DIR/dynamic_partitions_op_list
	fi
		if [ "$pacall" = "y" ];then
			echo 
			echo 打包 $sf
			rm -f ${sf}.img > /dev/null
			rm -f ${sf}.s.img > /dev/null
			#自动补全fs_config
			if [ "$configcompl" = "1" ];then
				find $sf|while read fs; do
				if ! grep -q "$fs 0" ./TI_config/${sf}_fs_config;then
					sed -i '$a\'"$fs 0 0 0777" ./TI_config/${sf}_fs_config
				fi
				done
			fi
			if [ "$syscheck" = "2" ];then
				$ebinner/mkfs.erofs --mount-point /${sf} --fs-config-file ./TI_config/${sf}_fs_config --file-contexts ./TI_config/${sf}_file_contexts TI_out/${sf}.img ./${sf} > /dev/null
			else
				MKE2FS_CONFIG=$binner/mke2fs.conf E2FSPROGS_FAKE_TIME=1230768000 $ebinner/mke2fs -O ^has_journal -L $sf -I 256 -M /$sf -m 0 -t ext4 -b 4096 $PROJECT_DIR/TI_out/$sf.s.img $sizes > /dev/null
				$ebinner/e2fsdroid -e -T 1230768000 -C $PROJECT_DIR/TI_config/${sf}_fs_config -S $PROJECT_DIR/TI_config/${sf}_file_contexts -f $PROJECT_DIR/$sf -a /$sf $PROJECT_DIR/TI_out/$sf.s.img > /dev/null
				$ebinner/img2simg ./TI_out/${sf}.s.img ./TI_out/${sf}.img > /dev/null
				rm -rf ./TI_out/${sf}.s.img > /dev/null
			fi
		else
		read -p "是否打包$sf?[y/n]" imgcheck </dev/tty
			if [ "$imgcheck" != "n" ];then
				echo 
				echo 打包 $sf
				rm -f ${sf}.img > /dev/null
				rm -f ${sf}.s.img > /dev/null
				#自动补全fs_config
				if [ "$configcompl" = "1" ];then
					find $sf|while read fs; do
					if ! grep -q "$fs 0" ./TI_config/${sf}_fs_config;then
						sed -i '$a\'"$fs 0 0 0777" ./TI_config/${sf}_fs_config
					fi
					done
				fi
			if [ "$syscheck" = "2" ];then
				$ebinner/mkfs.erofs --mount-point /${sf} --fs-config-file ./TI_config/${sf}_fs_config --file-contexts ./TI_config/${sf}_file_contexts TI_out/${sf}.img ./${sf} > /dev/null
			else
				MKE2FS_CONFIG=$binner/mke2fs.conf E2FSPROGS_FAKE_TIME=1230768000 $ebinner/mke2fs -O ^has_journal -L $sf -I 256 -M /$sf -m 0 -t ext4 -b 4096 $PROJECT_DIR/TI_out/$sf.s.img $sizes > /dev/null
				$ebinner/e2fsdroid -e -T 1230768000 -C $PROJECT_DIR/TI_config/${sf}_fs_config -S $PROJECT_DIR/TI_config/${sf}_file_contexts -f $PROJECT_DIR/$sf -a /$sf $PROJECT_DIR/TI_out/$sf.s.img > /dev/null
				$ebinner/img2simg ./TI_out/${sf}.s.img ./TI_out/${sf}.img > /dev/null
				rm -rf ./TI_out/${sf}.s.img > /dev/null
			fi
			fi
		fi
	done
else
echo "	没有可打包文件！"
fi
packmenu
}


function packimgst()
{
clear
cd $LOCALDIR && cd $project
echo -e "\033[33m 	<-打包IMG \033[0m" 
PROJECT_DIR=$LOCALDIR/$project
if [[ ! -d "TI_out" ]]; then
mkdir $PROJECT_DIR/TI_out
fi
if ls ./TI_config/*.boot >/dev/null 2>&1;then
	read -p "是否打包所有启动镜像？ [y/n]" pacall
	if [ "$pacall" != "y" ];then
	echo "跳过自动打包！"
	fi
	pacimglist=$(ls ./TI_config/*.boot)
	ls ./TI_config/*.boot | while read i; do
	sf=$(echo "$i" | cut -d"/" -f3| cut -d"." -f1)
	info=$(file $i)
	rm -rf $AIK/split_img
	rm -rf $AIK/ramdisk
	rm -rf $AIK/*.img
	if [ -e $AIK/ramdisk-new.cpio.gz ]; then
		rm -rf $AIK/ramdisk-new.cpio.gz
	fi
		if [ "$pacall" = "y" ];then
			echo 打包 $sf.img
			bootpac
		else
		read -p "是否打包$sf.img?[y/n]" imgcheck </dev/tty
			if [ "$imgcheck" != "n" ];then
				echo 打包 $sf.img
				bootpac
			fi
		fi
	done
fi
if ls ./TI_config/*_fs_config >/dev/null 2>&1;then
	read -p "是否打包所有系统镜像？ [y/n]" pacall
	if [ "$pacall" != "y" ];then
	echo "跳过自动打包！"
	fi
	read -p "打包文件系统?[1]ext4 [2]erofs" syscheck
	ls ./TI_config/*_fs_config | while read i; do
	sf=$(echo "$i" | cut -d"/" -f3 | rev | cut -d'_' -f1 --complement | cut -d'_' -f1 --complement | rev)
	part="$LOCALDIR/$project/$sf"
	sizes=`cat $sf'_size.txt'`
		if [ "$pacall" = "y" ];then
			echo 
			echo 打包 $sf
			rm -f ${sf}.img > /dev/null
			rm -f ${sf}.s.img > /dev/null
			#自动补全fs_config
			if [ "$configcompl" = "1" ];then
				find $sf|while read fs; do
				if ! grep -q "$fs 0" ./TI_config/${sf}_fs_config;then
					sed -i '$a\'"$fs 0 0 0777" ./TI_config/${sf}_fs_config
				fi
				done
			fi
			if [ "$syscheck" = "2" ];then
				$ebinner/mkfs.erofs --mount-point /${sf} --fs-config-file ./TI_config/${sf}_fs_config --file-contexts ./TI_config/${sf}_file_contexts TI_out/${sf}.img ./${sf} > /dev/null
			else
				$ebinner/make_ext4fs -s -l $sizes -L $sf -a $sf -S $sf'_file_contexts' -C $sf'_fs_config' -T 2009110000 $PROJECT_DIR/TI_out/$sf'.s.img' $sf > /dev/null
				$ebinner/img2simg ./TI_out/${sf}.s.img ./TI_out/${sf}.img > /dev/null
				rm -rf ./TI_out/${sf}.s.img > /dev/null
			fi
		else
		read -p "是否打包$sf?[y/n]" imgcheck </dev/tty
			if [ "$imgcheck" != "n" ];then
				echo 
				echo 打包 $sf
				rm -f ${sf}.img > /dev/null
				rm -f ${sf}.s.img > /dev/null
				#自动补全fs_config
				if [ "$configcompl" = "1" ];then
					find $sf|while read fs; do
					if ! grep -q "$fs 0" ./TI_config/${sf}_fs_config;then
						sed -i '$a\'"$fs 0 0 0777" ./TI_config/${sf}_fs_config
					fi
					done
				fi
			if [ "$syscheck" = "2" ];then
				$ebinner/mkfs.erofs --mount-point /${sf} --fs-config-file ./TI_config/${sf}_fs_config --file-contexts ./TI_config/${sf}_file_contexts TI_out/${sf}.img ./${sf} > /dev/null
			else
				$ebinner/make_ext4fs -s -l $sizes -L $sf -a $sf -S $sf'_file_contexts' -C $sf'_fs_config' -T 2009110000 $PROJECT_DIR/TI_out/$sf'.s.img' $sf > /dev/null
				$ebinner/img2simg ./TI_out/${sf}.s.img ./TI_out/${sf}.img > /dev/null
				rm -rf ./TI_out/${sf}.s.img > /dev/null
			fi
			fi
		fi
	done
else
echo "	没有可打包文件！"
fi
packmenu
}


# 打包dat
function packdatdy()
{
clear
cd $LOCALDIR && cd $project
echo -e "\033[33m 	<-打包DAT \033[0m" 
PROJECT_DIR=$LOCALDIR/$project
if [[ ! -d "TI_out" ]]; then
mkdir $PROJECT_DIR/TI_out
fi
if ls ./TI_config/*.boot >/dev/null 2>&1;then
	read -p "是否打包所有启动镜像？ [y/n]" pacall
	if [ "$pacall" != "y" ];then
	echo "跳过自动打包！"
	fi
	pacimglist=$(ls ./TI_config/*.boot)
	ls ./TI_config/*.boot | while read i; do
	sf=$(echo "$i" | cut -d"/" -f3| cut -d"." -f1)
	info=$(file $i)
	rm -rf $AIK/split_img
	rm -rf $AIK/ramdisk
	rm -rf $AIK/*.img
	if [ -e $AIK/ramdisk-new.cpio.gz ]; then
		rm -rf $AIK/ramdisk-new.cpio.gz
	fi
		if [ "$pacall" = "y" ];then
			echo 打包 $sf.img
			bootpac
		else
		read -p "是否打包$sf.img?[y/n]" imgcheck </dev/tty
			if [ "$imgcheck" != "n" ];then
				echo 打包 $sf.img
				bootpac
			fi
		fi
	done
fi
if ls ./TI_config/*_fs_config >/dev/null 2>&1;then
	read -p "是否打包所有系统镜像？ [y/n]" pacall
	if [ "$pacall" != "y" ];then
	echo "跳过自动打包！"
	fi
	read -p "打包文件系统?[1]ext4 [2]erofs" syscheck
	ls ./TI_config/*_fs_config | while read i; do
	sf=$(echo "$i" | cut -d"/" -f3 | rev | cut -d'_' -f1 --complement | cut -d'_' -f1 --complement | rev)
	part="$LOCALDIR/$project/$sf"
	zj=`du -sb $part | awk {'print $1'}`
	if [ $zj -gt 10000000 ] ; then
		dbzj=`echo "$zj * 1.0758" |bc`
	else
		dbzj=`echo "$zj * 1.2" |bc`  
	fi
	op=`echo $dbzj|sed 's/\..*//g'`
	echo $op >$PROJECT_DIR/TI_config/${sf}_size.txt
	sizes=`echo "$dbzj / 4096" |bc`
	if [[ -f "dynamic_partitions_op_list" ]]; then
	sed -i "s/resize ${sf}\s.*/resize ${sf} $op/" $PROJECT_DIR/dynamic_partitions_op_list
	fi
		if [ "$pacall" = "y" ];then
			echo 
			echo 打包 $sf
			rm -f ${sf}.datr.img > /dev/null
			rm -f ${sf}.new.dat > /dev/null
			rm -f ${sf}.patch.dat > /dev/null
			rm -f ${sf}.transfer.list > /dev/null
			#自动补全fs_config
			if [ "$configcompl" = "1" ];then
				find $sf|while read fs; do
				if ! grep -q "$fs 0" ./TI_config/${sf}_fs_config;then
					sed -i '$a\'"$fs 0 0 0777" ./TI_config/${sf}_fs_config
				fi
				done
			fi
			if [ "$syscheck" = "2" ];then
				$ebinner/mkfs.erofs --mount-point /${sf} --fs-config-file ./TI_config/${sf}_fs_config --file-contexts ./TI_config/${sf}_file_contexts TI_out/${sf}.datr.img ./${sf} > /dev/null
				$ebinner/img2simg ./TI_out/${sf}.datr.img ./TI_out/${sf}.datrsp.img > /dev/null
				rm -rf ./TI_out/${sf}.datr.img > /dev/null
				python3 $binner/img2sdat/img2sdat.py ./TI_out/${sf}.datrsp.img -o ./TI_out/ -v 4 -p ${sf} > /dev/null
				rm -rf ./TI_out/${sf}.datrsp.img > /dev/null
			else
				MKE2FS_CONFIG=$binner/mke2fs.conf E2FSPROGS_FAKE_TIME=1230768000 $ebinner/mke2fs -O ^has_journal -L $sf -I 256 -M /$sf -m 0 -t ext4 -b 4096 $PROJECT_DIR/TI_out/$sf.datr.img $sizes > /dev/null
				$ebinner/e2fsdroid -e -T 1230768000 -C $PROJECT_DIR/TI_config/${sf}_fs_config -S $PROJECT_DIR/TI_config/${sf}_file_contexts -f $PROJECT_DIR/$sf -a /$sf $PROJECT_DIR/TI_out/$sf.datr.img > /dev/null
				$ebinner/img2simg ./TI_out/${sf}.datr.img ./TI_out/${sf}.datrsp.img > /dev/null
				rm -rf ./TI_out/${sf}.datr.img > /dev/null
				python3 $binner/img2sdat/img2sdat.py ./TI_out/${sf}.datrsp.img -o ./TI_out/ -v 4 -p ${sf} > /dev/null
				rm -rf ./TI_out/${sf}.datrsp.img > /dev/null
			fi
		else
		read -p "是否打包$sf?[y/n]" imgcheck </dev/tty
			if [ "$imgcheck" != "n" ];then
				echo 
				echo 打包 $sf
			rm -f ${sf}.datr.img > /dev/null
			rm -f ${sf}.new.dat > /dev/null
			rm -f ${sf}.patch.dat > /dev/null
			rm -f ${sf}.transfer.list > /dev/null
				#自动补全fs_config
				if [ "$configcompl" = "1" ];then
					find $sf|while read fs; do
					if ! grep -q "$fs 0" ./TI_config/${sf}_fs_config;then
						sed -i '$a\'"$fs 0 0 0777" ./TI_config/${sf}_fs_config
					fi
					done
				fi
			if [ "$syscheck" = "2" ];then
				$ebinner/mkfs.erofs --mount-point /${sf} --fs-config-file ./TI_config/${sf}_fs_config --file-contexts ./TI_config/${sf}_file_contexts TI_out/${sf}.datr.img ./${sf} > /dev/null
				$ebinner/img2simg ./TI_out/${sf}.datr.img ./TI_out/${sf}.datrsp.img > /dev/null
				rm -rf ./TI_out/${sf}.datr.img > /dev/null
				python3 $binner/img2sdat/img2sdat.py ./TI_out/${sf}.datrsp.img -o ./TI_out/ -v 4 -p ${sf} > /dev/null
				rm -rf ./TI_out/${sf}.datrsp.img > /dev/null
			else
				MKE2FS_CONFIG=$binner/mke2fs.conf E2FSPROGS_FAKE_TIME=1230768000 $ebinner/mke2fs -O ^has_journal -L $sf -I 256 -M /$sf -m 0 -t ext4 -b 4096 $PROJECT_DIR/TI_out/$sf.datr.img $sizes > /dev/null
				$ebinner/e2fsdroid -e -T 1230768000 -C $PROJECT_DIR/TI_config/${sf}_fs_config -S $PROJECT_DIR/TI_config/${sf}_file_contexts -f $PROJECT_DIR/$sf -a /$sf $PROJECT_DIR/TI_out/$sf.datr.img > /dev/null
				$ebinner/img2simg ./TI_out/${sf}.datr.img ./TI_out/${sf}.datrsp.img > /dev/null
				rm -rf ./TI_out/${sf}.datr.img > /dev/null
				python3 $binner/img2sdat/img2sdat.py ./TI_out/${sf}.datrsp.img -o ./TI_out/ -v 4 -p ${sf} > /dev/null
				rm -rf ./TI_out/${sf}.datrsp.img > /dev/null
			fi
			fi
		fi
	done

else
echo "	没有可打包文件！"
fi
packmenu
}



# 打包dat
function packdatst()
{
clear
cd $LOCALDIR && cd $project
echo -e "\033[33m 	<-打包DAT \033[0m" 
PROJECT_DIR=$LOCALDIR/$project
if [[ ! -d "TI_out" ]]; then
mkdir $PROJECT_DIR/TI_out
fi
if ls ./TI_config/*.boot >/dev/null 2>&1;then
	read -p "是否打包所有启动镜像？ [y/n]" pacall
	if [ "$pacall" != "y" ];then
	echo "跳过自动打包！"
	fi
	pacimglist=$(ls ./TI_config/*.boot)
	ls ./TI_config/*.boot | while read i; do
	sf=$(echo "$i" | cut -d"/" -f3| cut -d"." -f1)
	info=$(file $i)
	rm -rf $AIK/split_img
	rm -rf $AIK/ramdisk
	rm -rf $AIK/*.img
	if [ -e $AIK/ramdisk-new.cpio.gz ]; then
		rm -rf $AIK/ramdisk-new.cpio.gz
	fi
		if [ "$pacall" = "y" ];then
			echo 打包 $sf.img
			bootpac
		else
		read -p "是否打包$sf.img?[y/n]" imgcheck </dev/tty
			if [ "$imgcheck" != "n" ];then
				echo 打包 $sf.img
				bootpac
			fi
		fi
	done
fi
if ls ./TI_config/*_fs_config >/dev/null 2>&1;then
	read -p "是否打包所有系统镜像？ [y/n]" pacall
	if [ "$pacall" != "y" ];then
	echo "跳过自动打包！"
	fi
	read -p "打包文件系统?[1]ext4 [2]erofs" syscheck
	ls ./TI_config/*_fs_config | while read i; do
	sf=$(echo "$i" | cut -d"/" -f3 | rev | cut -d'_' -f1 --complement | cut -d'_' -f1 --complement | rev)
	part="$LOCALDIR/$project/$sf"
	sizes=`cat $sf'_size.txt'`
		if [ "$pacall" = "y" ];then
			echo 
			echo 打包 $sf
			rm -f ${sf}.datr.img > /dev/null
			rm -f ${sf}.new.dat > /dev/null
			rm -f ${sf}.patch.dat > /dev/null
			rm -f ${sf}.transfer.list > /dev/null
			#自动补全fs_config
			if [ "$configcompl" = "1" ];then
				find $sf|while read fs; do
				if ! grep -q "$fs 0" ./TI_config/${sf}_fs_config;then
					sed -i '$a\'"$fs 0 0 0777" ./TI_config/${sf}_fs_config
				fi
				done
			fi
			if [ "$syscheck" = "2" ];then
				$ebinner/mkfs.erofs --mount-point /${sf} --fs-config-file ./TI_config/${sf}_fs_config --file-contexts ./TI_config/${sf}_file_contexts TI_out/${sf}.datr.img ./${sf} > /dev/null
				$ebinner/img2simg ./TI_out/${sf}.datr.img ./TI_out/${sf}.datrsp.img > /dev/null
				rm -rf ./TI_out/${sf}.datr.img > /dev/null
				python3 $binner/img2sdat/img2sdat.py ./TI_out/${sf}.datrsp.img -o ./TI_out/ -v 4 -p ${sf} > /dev/null
				rm -rf ./TI_out/${sf}.datrsp.img > /dev/null
			else
				$ebinner/make_ext4fs -s -l $sizes -L $sf -a $sf -S $sf'_file_contexts' -C $sf'_fs_config' -T 2009110000 $PROJECT_DIR/TI_out/$sf'.datr.img' $sf > /dev/null
				$ebinner/img2simg ./TI_out/${sf}.datr.img ./TI_out/${sf}.datrsp.img > /dev/null
				rm -rf ./TI_out/${sf}.datr.img > /dev/null
				python3 $binner/img2sdat/img2sdat.py ./TI_out/${sf}.datrsp.img -o ./TI_out/ -v 4 -p ${sf} > /dev/null
				rm -rf ./TI_out/${sf}.datrsp.img > /dev/null
			fi
		else
		read -p "是否打包$sf?[y/n]" imgcheck </dev/tty
			if [ "$imgcheck" != "n" ];then
				echo 
				echo 打包 $sf
			rm -f ${sf}.datr.img > /dev/null
			rm -f ${sf}.new.dat > /dev/null
			rm -f ${sf}.patch.dat > /dev/null
			rm -f ${sf}.transfer.list > /dev/null
				#自动补全fs_config
				if [ "$configcompl" = "1" ];then
					find $sf|while read fs; do
					if ! grep -q "$fs 0" ./TI_config/${sf}_fs_config;then
						sed -i '$a\'"$fs 0 0 0777" ./TI_config/${sf}_fs_config
					fi
					done
				fi
			if [ "$syscheck" = "2" ];then
				$ebinner/mkfs.erofs --mount-point /${sf} --fs-config-file ./TI_config/${sf}_fs_config --file-contexts ./TI_config/${sf}_file_contexts TI_out/${sf}.datr.img ./${sf} > /dev/null
				$ebinner/img2simg ./TI_out/${sf}.datr.img ./TI_out/${sf}.datrsp.img > /dev/null
				rm -rf ./TI_out/${sf}.datr.img > /dev/null
				python3 $binner/img2sdat/img2sdat.py ./TI_out/${sf}.datrsp.img -o ./TI_out/ -v 4 -p ${sf} > /dev/null
				rm -rf ./TI_out/${sf}.datrsp.img > /dev/null
			else
				$ebinner/make_ext4fs -s -l $sizes -L $sf -a $sf -S $sf'_file_contexts' -C $sf'_fs_config' -T 2009110000 $PROJECT_DIR/TI_out/$sf'.datr.img' $sf > /dev/null
				$ebinner/img2simg ./TI_out/${sf}.datr.img ./TI_out/${sf}.datrsp.img > /dev/null
				rm -rf ./TI_out/${sf}.datr.img > /dev/null
				python3 $binner/img2sdat/img2sdat.py ./TI_out/${sf}.datrsp.img -o ./TI_out/ -v 4 -p ${sf} > /dev/null
				rm -rf ./TI_out/${sf}.datrsp.img > /dev/null
			fi
			fi
		fi
	done

else
echo "	没有可打包文件！"
fi
packmenu
}



# 打包br
function packbrdy()
{
clear
cd $LOCALDIR && cd $project
echo -e "\033[33m 	<-打包Bro \033[0m" 
PROJECT_DIR=$LOCALDIR/$project
if [[ ! -d "TI_out" ]]; then
mkdir $PROJECT_DIR/TI_out
fi
if ls ./TI_config/*.boot >/dev/null 2>&1;then
	read -p "是否打包所有启动镜像？ [y/n]" pacall
	if [ "$pacall" != "y" ];then
	echo "跳过自动打包！"
	fi
	pacimglist=$(ls ./TI_config/*.boot)
	ls ./TI_config/*.boot | while read i; do
	sf=$(echo "$i" | cut -d"/" -f3| cut -d"." -f1)
	info=$(file $i)
	rm -rf $AIK/split_img
	rm -rf $AIK/ramdisk
	rm -rf $AIK/*.img
	if [ -e $AIK/ramdisk-new.cpio.gz ]; then
		rm -rf $AIK/ramdisk-new.cpio.gz
	fi
		if [ "$pacall" = "y" ];then
			echo 打包 $sf
			bootpac
		else
		read -p "是否打包$sf.img?[y/n]" imgcheck </dev/tty
			if [ "$imgcheck" != "n" ];then
				echo 打包 $sf
				bootpac
			fi
		fi
	done
fi
if ls ./TI_config/*_fs_config >/dev/null 2>&1;then
	read -p "是否打包所有系统镜像？ [y/n]" pacall
	if [ "$pacall" != "y" ];then
	echo "跳过自动打包！"
	fi
	read -p "打包文件系统?[1]ext4 [2]erofs" syscheck
	ls ./TI_config/*_fs_config | while read i; do
	sf=$(echo "$i" | cut -d"/" -f3 | rev | cut -d'_' -f1 --complement | cut -d'_' -f1 --complement | rev)
	part="$LOCALDIR/$project/$sf"
	zj=`du -sb $part | awk {'print $1'}`
	if [ $zj -gt 10000000 ] ; then
		dbzj=`echo "$zj * 1.0758" |bc`
	else
		dbzj=`echo "$zj * 1.2" |bc`  
	fi
	op=`echo $dbzj|sed 's/\..*//g'`
	echo $op >$PROJECT_DIR/TI_config/${sf}_size.txt
	sizes=`echo "$dbzj / 4096" |bc`
	if [[ -f "dynamic_partitions_op_list" ]]; then
	sed -i "s/resize ${sf}\s.*/resize ${sf} $op/" $PROJECT_DIR/dynamic_partitions_op_list
	fi
		if [ "$pacall" = "y" ];then
			echo 
			echo 打包 $sf
			rm -f ${sf}.br.img > /dev/null
			rm -f ${sf}.brsp.img > /dev/null
			rm -f ${sf}.new.dat > /dev/null
			rm -f ${sf}.new.dat.br > /dev/null
			rm -f ${sf}.patch.dat > /dev/null
			rm -f ${sf}.transfer.list > /dev/null
			#自动补全fs_config
			if [ "$configcompl" = "1" ];then
				find $sf|while read fs; do
				if ! grep -q "$fs 0" ./TI_config/${sf}_fs_config;then
					sed -i '$a\'"$fs 0 0 0777" ./TI_config/${sf}_fs_config
				fi
				done
			fi
			if [ "$syscheck" = "2" ];then
				$ebinner/mkfs.erofs --mount-point /${sf} --fs-config-file ./TI_config/${sf}_fs_config --file-contexts ./TI_config/${sf}_file_contexts TI_out/${sf}.br.img ./${sf} > /dev/null
				$ebinner/img2simg ./TI_out/${sf}.br.img ./TI_out/${sf}.brsp.img > /dev/null
				rm -rf ./TI_out/${sf}.br.img > /dev/null
				python3 $binner/img2sdat/img2sdat.py ./TI_out/${sf}.brsp.img -o ./TI_out/ -v 4 -p ${sf} > /dev/null
				rm -rf ./TI_out/${sf}.brsp.img > /dev/null
				$ebinner/brotli -q $brcom ./TI_out/${sf}.new.dat -o ./TI_out/${sf}.new.dat.br > /dev/null
				rm -rf ./TI_out/${sf}.new.dat > /dev/null
			else
				MKE2FS_CONFIG=$binner/mke2fs.conf E2FSPROGS_FAKE_TIME=1230768000 $ebinner/mke2fs -O ^has_journal -L $sf -I 256 -M /$sf -m 0 -t ext4 -b 4096 $PROJECT_DIR/TI_out/$sf.br.img $sizes > /dev/null
				$ebinner/e2fsdroid -e -T 1230768000 -C $PROJECT_DIR/TI_config/${sf}_fs_config -S $PROJECT_DIR/TI_config/${sf}_file_contexts -f $PROJECT_DIR/$sf -a /$sf $PROJECT_DIR/TI_out/$sf.br.img > /dev/null
				$ebinner/img2simg ./TI_out/${sf}.br.img ./TI_out/${sf}.brsp.img > /dev/null
				rm -rf ./TI_out/${sf}.br.img > /dev/null
				python3 $binner/img2sdat/img2sdat.py ./TI_out/${sf}.brsp.img -o ./TI_out/ -v 4 -p ${sf} > /dev/null
				rm -rf ./TI_out/${sf}.brsp.img > /dev/null
				$ebinner/brotli -q $brcom ./TI_out/${sf}.new.dat -o ./TI_out/${sf}.new.dat.br > /dev/null
				rm -rf ./TI_out/${sf}.new.dat > /dev/null
			fi
		else
		read -p "是否打包$sf?[y/n]" imgcheck </dev/tty
			if [ "$imgcheck" != "n" ];then
				echo 
				echo 打包 $sf
				rm -f ${sf}.br.img > /dev/null
				rm -f ${sf}.brsp.img > /dev/null
				rm -f ${sf}.new.dat > /dev/null
				rm -f ${sf}.new.dat.br > /dev/null
				rm -f ${sf}.patch.dat > /dev/null
				rm -f ${sf}.transfer.list > /dev/null
				#自动补全fs_config
				if [ "$configcompl" = "1" ];then
					find $sf|while read fs; do
					if ! grep -q "$fs 0" ./TI_config/${sf}_fs_config;then
						sed -i '$a\'"$fs 0 0 0777" ./TI_config/${sf}_fs_config
					fi
					done
				fi
			if [ "$syscheck" = "2" ];then
				$ebinner/mkfs.erofs --mount-point /${sf} --fs-config-file ./TI_config/${sf}_fs_config --file-contexts ./TI_config/${sf}_file_contexts TI_out/${sf}.br.img ./${sf} > /dev/null
				$ebinner/img2simg ./TI_out/${sf}.br.img ./TI_out/${sf}.brsp.img > /dev/null
				rm -rf ./TI_out/${sf}.br.img > /dev/null
				python3 $binner/img2sdat/img2sdat.py ./TI_out/${sf}.brsp.img -o ./TI_out/ -v 4 -p ${sf} > /dev/null
				rm -rf ./TI_out/${sf}.brsp.img > /dev/null
				$ebinner/brotli -q $brcom ./TI_out/${sf}.new.dat -o ./TI_out/${sf}.new.dat.br > /dev/null
				rm -rf ./TI_out/${sf}.new.dat > /dev/null
			else
				MKE2FS_CONFIG=$binner/mke2fs.conf E2FSPROGS_FAKE_TIME=1230768000 $ebinner/mke2fs -O ^has_journal -L $sf -I 256 -M /$sf -m 0 -t ext4 -b 4096 $PROJECT_DIR/TI_out/$sf.br.img $sizes > /dev/null
				$ebinner/e2fsdroid -e -T 1230768000 -C $PROJECT_DIR/TI_config/${sf}_fs_config -S $PROJECT_DIR/TI_config/${sf}_file_contexts -f $PROJECT_DIR/$sf -a /$sf $PROJECT_DIR/TI_out/$sf.br.img > /dev/null
				$ebinner/img2simg ./TI_out/${sf}.br.img ./TI_out/${sf}.brsp.img > /dev/null
				rm -rf ./TI_out/${sf}.br.img > /dev/null
				python3 $binner/img2sdat/img2sdat.py ./TI_out/${sf}.brsp.img -o ./TI_out/ -v 4 -p ${sf} > /dev/null
				rm -rf ./TI_out/${sf}.brsp.img > /dev/null
				$ebinner/brotli -q $brcom ./TI_out/${sf}.new.dat -o ./TI_out/${sf}.new.dat.br > /dev/null
				rm -rf ./TI_out/${sf}.new.dat > /dev/null
			fi
			fi
		fi
	done
else
echo "	没有可打包文件！"
fi
packmenu
}



# 打包br
function packbrst()
{
clear
cd $LOCALDIR && cd $project
echo -e "\033[33m 	<-打包Bro \033[0m" 
PROJECT_DIR=$LOCALDIR/$project
if [[ ! -d "TI_out" ]]; then
mkdir $PROJECT_DIR/TI_out
fi
if ls ./TI_config/*.boot >/dev/null 2>&1;then
	read -p "是否打包所有启动镜像？ [y/n]" pacall
	if [ "$pacall" != "y" ];then
	echo "跳过自动打包！"
	fi
	pacimglist=$(ls ./TI_config/*.boot)
	ls ./TI_config/*.boot | while read i; do
	sf=$(echo "$i" | cut -d"/" -f3| cut -d"." -f1)
	info=$(file $i)
	rm -rf $AIK/split_img
	rm -rf $AIK/ramdisk
	rm -rf $AIK/*.img
	if [ -e $AIK/ramdisk-new.cpio.gz ]; then
		rm -rf $AIK/ramdisk-new.cpio.gz
	fi
		if [ "$pacall" = "y" ];then
			echo 打包 $sf
			bootpac
		else
		read -p "是否打包$sf.img?[y/n]" imgcheck </dev/tty
			if [ "$imgcheck" != "n" ];then
				echo 打包 $sf
				bootpac
			fi
		fi
	done
fi
if ls ./TI_config/*_fs_config >/dev/null 2>&1;then
	read -p "是否打包所有系统镜像？ [y/n]" pacall
	if [ "$pacall" != "y" ];then
	echo "跳过自动打包！"
	fi
	read -p "打包文件系统?[1]ext4 [2]erofs" syscheck
	ls ./TI_config/*_fs_config | while read i; do
	sf=$(echo "$i" | cut -d"/" -f3 | rev | cut -d'_' -f1 --complement | cut -d'_' -f1 --complement | rev)
	part="$LOCALDIR/$project/$sf"
	sizes=`cat $sf'_size.txt'`
		if [ "$pacall" = "y" ];then
			echo 
			echo 打包 $sf
			rm -f ${sf}.br.img > /dev/null
			rm -f ${sf}.brsp.img > /dev/null
			rm -f ${sf}.new.dat > /dev/null
			rm -f ${sf}.new.dat.br > /dev/null
			rm -f ${sf}.patch.dat > /dev/null
			rm -f ${sf}.transfer.list > /dev/null
			#自动补全fs_config
			if [ "$configcompl" = "1" ];then
				find $sf|while read fs; do
				if ! grep -q "$fs 0" ./TI_config/${sf}_fs_config;then
					sed -i '$a\'"$fs 0 0 0777" ./TI_config/${sf}_fs_config
				fi
				done
			fi
			if [ "$syscheck" = "2" ];then
				$ebinner/mkfs.erofs --mount-point /${sf} --fs-config-file ./TI_config/${sf}_fs_config --file-contexts ./TI_config/${sf}_file_contexts TI_out/${sf}.br.img ./${sf} > /dev/null
				$ebinner/img2simg ./TI_out/${sf}.br.img ./TI_out/${sf}.brsp.img > /dev/null
				rm -rf ./TI_out/${sf}.br.img > /dev/null
				python3 $binner/img2sdat/img2sdat.py ./TI_out/${sf}.brsp.img -o ./TI_out/ -v 4 -p ${sf} > /dev/null
				rm -rf ./TI_out/${sf}.brsp.img > /dev/null
				$ebinner/brotli -q $brcom ./TI_out/${sf}.new.dat -o ./TI_out/${sf}.new.dat.br > /dev/null
				rm -rf ./TI_out/${sf}.new.dat > /dev/null
			else
				$ebinner/make_ext4fs -s -l $sizes -L $sf -a $sf -S $sf'_file_contexts' -C $sf'_fs_config' -T 2009110000 $PROJECT_DIR/TI_out/$sf'.br.img' $sf > /dev/null
				$ebinner/img2simg ./TI_out/${sf}.br.img ./TI_out/${sf}.brsp.img > /dev/null
				rm -rf ./TI_out/${sf}.br.img > /dev/null
				python3 $binner/img2sdat/img2sdat.py ./TI_out/${sf}.brsp.img -o ./TI_out/ -v 4 -p ${sf} > /dev/null
				rm -rf ./TI_out/${sf}.brsp.img > /dev/null
				$ebinner/brotli -q $brcom ./TI_out/${sf}.new.dat -o ./TI_out/${sf}.new.dat.br > /dev/null
				rm -rf ./TI_out/${sf}.new.dat > /dev/null
			fi
		else
		read -p "是否打包$sf?[y/n]" imgcheck </dev/tty
			if [ "$imgcheck" != "n" ];then
				echo 
				echo 打包 $sf
				rm -f ${sf}.br.img > /dev/null
				rm -f ${sf}.brsp.img > /dev/null
				rm -f ${sf}.new.dat > /dev/null
				rm -f ${sf}.new.dat.br > /dev/null
				rm -f ${sf}.patch.dat > /dev/null
				rm -f ${sf}.transfer.list > /dev/null
				#自动补全fs_config
				if [ "$configcompl" = "1" ];then
					find $sf|while read fs; do
					if ! grep -q "$fs 0" ./TI_config/${sf}_fs_config;then
						sed -i '$a\'"$fs 0 0 0777" ./TI_config/${sf}_fs_config
					fi
					done
				fi
			if [ "$syscheck" = "2" ];then
				$ebinner/mkfs.erofs --mount-point /${sf} --fs-config-file ./TI_config/${sf}_fs_config --file-contexts ./TI_config/${sf}_file_contexts TI_out/${sf}.br.img ./${sf} > /dev/null
				$ebinner/img2simg ./TI_out/${sf}.br.img ./TI_out/${sf}.brsp.img > /dev/null
				rm -rf ./TI_out/${sf}.br.img > /dev/null
				python3 $binner/img2sdat/img2sdat.py ./TI_out/${sf}.brsp.img -o ./TI_out/ -v 4 -p ${sf} > /dev/null
				rm -rf ./TI_out/${sf}.brsp.img > /dev/null
				$ebinner/brotli -q $brcom ./TI_out/${sf}.new.dat -o ./TI_out/${sf}.new.dat.br > /dev/null
				rm -rf ./TI_out/${sf}.new.dat > /dev/null
			else
				$ebinner/make_ext4fs -s -l $sizes -L $sf -a $sf -S $sf'_file_contexts' -C $sf'_fs_config' -T 2009110000 $PROJECT_DIR/TI_out/$sf'.br.img' $sf > /dev/null
				$ebinner/img2simg ./TI_out/${sf}.br.img ./TI_out/${sf}.brsp.img > /dev/null
				rm -rf ./TI_out/${sf}.br.img > /dev/null
				python3 $binner/img2sdat/img2sdat.py ./TI_out/${sf}.brsp.img -o ./TI_out/ -v 4 -p ${sf} > /dev/null
				rm -rf ./TI_out/${sf}.brsp.img > /dev/null
				$ebinner/brotli -q $brcom ./TI_out/${sf}.new.dat -o ./TI_out/${sf}.new.dat.br > /dev/null
				rm -rf ./TI_out/${sf}.new.dat > /dev/null
			fi
			fi
		fi
	done
else
echo "	没有可打包文件！"
fi
packmenu
}



# 解压br
function unbr()
{
clear
cd $LOCALDIR && cd $project
echo -e "\033[33m 	<-分解BRO \033[0m" 
if ls *.br >/dev/null 2>&1;then
	read -p "是否解压所有br?[y/n]" brall
	if [ "$brall" != "y" ];then
	echo "跳过自动解压！"
	fi	
	read -p "是否解压后删除所有源br?[y/n]" brdelall
	if [ "$brdelall" != "y" ];then
	echo "解压后保留所有源br！"
	fi
	ls ./*.new.dat.br | while read i; do
		line=$(echo "$i" | cut -d"/" -f3| cut -d"." -f1)
		if [ "$brall" == "y" ];then
			clear
			echo 解压 $i
			$ebinner/brotli -d $i > /dev/null 2>&1
			rm -rf $i
		else
			read -p "是否解包$i?[y/n]" brcheck </dev/tty
			if [ "$brcheck" != "n" ];then
				clear
				echo 解压 $i
				$ebinner/brotli -d $i > /dev/null
			fi
		fi
		if [ "$brcheck" = "y" ];then
			if [ "$brdelall" = "y" ];then
				rm -f $i
			else
				read -p "是否删除$i?[y/n]" brdel </dev/tty
				if [ "$brdel" = "y" ];then
					rm -f $i
				else
					echo "已跳过删除$i！"
				fi
			fi
		fi
	done
else
echo 
echo "	没有br压缩文件！"
sleep $sleeptime
fi
unpmenu
}


# 解压ofp
function unofp()
{
clear
cd $LOCALDIR && cd $project
echo -e "\033[33m 	<-分解OFP \033[0m" 
if ls *.ofp >/dev/null 2>&1;then
	read -p "是否解压所有ofp?[y/n]" ofpall
	if [ "$ofpall" != "y" ];then
	echo "跳过自动解压！"
	fi	
	read -p "您的处理器为？?[1]高通 [2]MTK" ofpm
	if [ "$ofm" = "2" ];then
	echo "跳过自动解压！"
	fi	
	ls *.ofp | while read i; do
		line=$(echo "$i" | cut -d"/" -f3| cut -d"." -f1)
		mkdir $line
		if [ "$ofpall" == "y" ];then
			clear
			echo 解压 $i
			if [ $ofpm = "2" ];then
			python3 $binner/oppo_decrypt/ofp_mtk_decrypt.py $LOCALDIR/$project/$i $LOCALDIR/$project/$line
			else
			python3 $binner/oppo_decrypt/ofp_qc_decrypt.py $LOCALDIR/$project/$i $LOCALDIR/$project/$line
			fi
			rm -rf $i
		else
			read -p "是否解包$i?[y/n]" ofpcheck </dev/tty
			if [ "$ofpcheck" != "n" ];then
				clear
				echo 解压 $i
			if [ $ofpm = "2" ];then
			 python3 $binner/oppo_decrypt/ofp_mtk_decrypt.py $LOCALDIR/$project/$i $LOCALDIR/$project/$line
			else
			 python3 $binner/oppo_decrypt/ofp_qc_decrypt.py $LOCALDIR/$project/$i $LOCALDIR/$project/$line
			fi
			fi
		fi
	done
else
echo 
echo "	没有ofp文件！"
echo 
sleep $sleeptime
fi
unpmenu
}


# 解压ops
function unops()
{
clear
cd $LOCALDIR && cd $project
echo -e "\033[33m 	<-分解OPS \033[0m" 
if ls *.ops >/dev/null 2>&1;then
	read -p "是否解压所有ops?[y/n]" ofpall
	if [ "$ofpall" != "y" ];then
	echo "跳过自动解压！"
	fi	
	if [ "$ofm" = "2" ];then
	echo "跳过自动解压！"
	fi	
	ls *.ops | while read i; do
		line=$(echo "$i" | cut -d"/" -f3| cut -d"." -f1)
		mkdir $line
		if [ "$ofpall" == "y" ];then
			clear
			echo 解压 $i
			if [ $ofpm = "2" ];then
			python3 $binner/oppo_decrypt/ofp_mtk_decrypt.py $LOCALDIR/$project/$i $LOCALDIR/$project/$line
			else
			python3 $binner/oppo_decrypt/ofp_qc_decrypt.py $LOCALDIR/$project/$i $LOCALDIR/$project/$line
			fi
			rm -rf $i
		else
			read -p "是否解包$i?[y/n]" ofpcheck </dev/tty
			if [ "$ofpcheck" != "n" ];then
				clear
				echo 解压 $i
			if [ $ofpm = "2" ];then
			 python3 $binner/oppo_decrypt/ofp_mtk_decrypt.py $LOCALDIR/$project/$i $LOCALDIR/$project/$line
			else
			 python3 $binner/oppo_decrypt/ofp_qc_decrypt.py $LOCALDIR/$project/$i $LOCALDIR/$project/$line
			fi
			fi
		fi
	done
else
echo 
echo "	没有ofp文件！"
echo 
sleep $sleeptime
fi
unpmenu
}



# 解压dat
function undat()
{
clear
cd $LOCALDIR && cd $project
echo -e "\033[33m 	<-分解DAT \033[0m" 
if ls *.dat >/dev/null 2>&1;then
	read -p "是否解压所有dat[y/n]" datall
	if [ "$datall" != "y" ];then
	echo "跳过自动解压！"
	fi	
	read -p "是否解压后删除所有源dat?[y/n]" datdelall
	if [ "$datdelall" != "y" ];then
	echo "解压后保留所有源dat！"
	fi
	ls *.new.dat | while read i; do
		line=$(echo "$i" | cut -d"/" -f3| cut -d"." -f1)
		if [ "$datall" == "y" ];then
			echo 解压 $i
			python3 $binner/sdat2img.py $line.transfer.list $line.new.dat ./$line.img
		else
			read -p "是否解包$i?[y/n]" datcheck </dev/tty
			if [ "$datcheck" != "n" ];then
				echo 解压 $i
				python3 $binner/sdat2img.py $line.transfer.list $line.new.dat ./$line.img
			fi
		fi
		if [ "$datcheck" = "y" ];then
			if [ "$datdelall" = "y" ];then
				rm -f $i
			else
				read -p "是否删除$i?[y/n]" datdel </dev/tty
				if [ "$datdel" = "y" ];then
					rm -f $i
				else
					echo "已跳过删除$i！"
				fi
			fi
		fi
	done
else
echo "	没有dat文件！"
fi
unpmenu
}


function undtbo()
{
cd $LOCALDIR && cd $project
echo -e "\033[33m 	<-分解DTBO \033[0m" 
rm -rf $dtbodir
if [ -f "./dtbo.img" ];then
 filedtbo="dtbo.img"
elif [ -f "./firmware-update/dtbo.img" ];then
 filedtbo="firmware-update/dtbo.img"
else
  echo "dtbo.img不存在！"
  sleep $sleeptime
  unpmenu
fi
dtc="$binner/dtb_tools/dtc"
mkdtimg_tool="$binner/dtb_tools/mkdtboimg.py"
dtbodir="./dtbo"
mkdir -p $dtbodir/dtbo_files
mkdir -p $dtbodir/dts_files
echo "正在解压dtbo.img"
python3 $mkdtimg_tool dump "./$filedtbo" -b "$dtbodir/dtbo_files/dtbo" > $dtbodir/dtbo_imageinfo.txt

dtbo_files_name=$(ls $dtbodir/dtbo_files)
for dtbo_files in $dtbo_files_name ;do
  dts_files=$(echo "$dtbo_files" | sed 's/dtbo/dts/g')
  echo "正在反编译$dtbo_files为$dts_files"
  $dtc -@ -I "dtb" -O "dts" "$dtbodir/dtbo_files/$dtbo_files" -o "$dtbodir/dts_files/$dts_files" > /dev/null 2>&1
  [ $? != 0 ] && echo "反编译$dtbo_files失败" && unpmenu
done
echo "解压完成"
chmod 777 -R $dtbodir
unpmenu
}


function undtb()
{
cd $LOCALDIR && cd $project
echo -e "\033[33m 	<-分解DTB \033[0m" 
rm -rf $dtbodir
if [ ! -e ./dtb ];then
  echo "dtb文件不存在！它或许存在于boot或者vendor_boot中，请解包后移至项目根目录"
  sleep $sleeptime
  unpmenu
fi
dtc="$binner/dtb_tools/dtc"
dtbdir="./dtbs"

rm -rf $dtbodir
mkdir -p $dtbdir/dts_files

echo "正在反编译dtb"
$dtc -@ -I "dtb" -O "dts" "./dtb" -o "$dtbdir/dts_files/dts" > /dev/null 2>&1
[ $? != 0 ] && echo "反编译dtb失败" && unpmenu
echo "反编译完成"
chmod 777 -R $dtbdir
unpmenu
}

# 自动解压
function autounpack()
{
mkdir TI_config
Yeliqin "自动解包阶段开始，将自动删除源文件！"
# payload.bin解包
if [ -f "./payload.bin" ]; then
	Yeliqin "解压 payload.bin..."
	python3 $binner/payload_dumper/payload_dumper.py payload.bin ./payload > /dev/null
	#mv ./payload/system.img ./payload/system_ext.img ./payload/boot.img ./payload/vendor_boot.img ./payload/vendor.img ./payload/odm.img ./payload/product.img ./
	#read -p "是否为erofs格式?[y/n]" erocheck
	#if [ "$erocheck" != "y" ];then
	#	echo 使用ext4解包分区...
	#	sudo python3 $binner/imgextractor.py ./system.img ./
	#	sudo python3 $binner/imgextractor.py ./system_ext.img ./
	#	sudo python3 $binner/imgextractor.py ./product.img ./
	#	sudo python3 $binner/imgextractor.py ./vendor.img ./
	#	sudo python3 $binner/imgextractor.py ./odm.img ./
	#else
	#	echo 使用erofs解包分区...
	#	sudo $ebinner/erofsUnpackKt ./system.img ./
	#	sudo $ebinner/erofsUnpackKt ./system_ext.img ./
	#	sudo $ebinner/erofsUnpackKt ./product.img ./
	#	sudo $ebinner/erofsUnpackKt ./vendor.img ./
	#	sudo $ebinner/erofsUnpackKt ./odm.img ./
	#	mv ./config ./TI_config
	#fi
	rm -rf payload.bin
	#rm -rf ./system.img
	#rm -rf ./system_ext.img
	#rm -rf ./product.img
	#rm -rf ./odm.img
	#rm -rf ./vendor.img
	payloadmenu
else
# 解压br文件
if ls *.br >/dev/null 2>&1;then
	ls *.new.dat.br | while read b; do
		sf=$(echo "$b" | cut -d"/" -f3| cut -d"." -f1)
		Yeliqin "解压 $sf..."
		sudo $ebinner/brotli -d ${b} > /dev/null 2>&1
		rm -rf $sf.new.dat.br
		sudo python3 $binner/sdat2img.py ${sf}.transfer.list ${sf}.new.dat ./${sf}.img > /dev/null 2>&1
		rm -rf ./${sf}.new.dat && rm -rf ./${sf}.patch.dat && rm -rf ./${sf}.transfer.list > /dev/null 2>&1
		info=$(file $sf.img)
		i=$sf.img
		imgextra
		rm -rf ./${sf}.img
		echo 
	done
fi

# 合并分段dat
if ls *.dat.1 >/dev/null 2>&1;then
	ls *.new.dat.1 | while read t; do
		th=$(echo "$t" | cut -d"/" -f3| cut -d"." -f1)
		Yeliqin "合并 $th.new.dat..."
		sudo cat ./${th}.new.dat.{1..999} 2>/dev/null >> ./${th}.new.dat > /dev/null 2>&1
		rm -rf ./${th}.new.dat.{1..999}
	done
fi

# 解压dat
if ls *.dat >/dev/null 2>&1;then
	ls *.new.dat | while read d; do
		sf=$(echo "$d" | cut -d"/" -f3| cut -d"." -f1)
		Yeliqin "解压 $sf..."
		sudo python3 $binner/sdat2img.py ${sf}.transfer.list ${sf}.new.dat ./${sf}.img > /dev/null 2>&1
		rm -rf ./${sf}.new.dat && rm -rf ./${sf}.patch.dat && rm -rf ./${sf}.transfer.list > /dev/null 2>&1
		Yeliqin "解压$sf..."
		info=$(file $sf.img)
		i=$sf.img
		imgextra
	done
fi

# 解压img
if ls *.img >/dev/null 2>&1;then
	ls *.img | while read i; do
		info=$(file $i)
		sf=$(echo "$i" | cut -d"/" -f3| cut -d"." -f1)
		Yeliqin "解压$i..."
		imgextra
	done
fi

# TWRP备份文件
if ls *.win000 >/dev/null 2>&1;then
	ls *.win000 | while read b; do
		bh=$(echo "$b" | cut -d"/" -f3| cut -d"." -f1)
		echo 合并 $bh 备份文件...
		sudo cat ./${bh}.win{1..999} 2>/dev/null >> ./${bh}.win
		rm -rf ./${bh}.win00{0..9}
		sleep $sleeptime
	done
fi
if ls *.win >/dev/null 2>&1;then
	ls *.win | while read b; do
		bh=$(echo "$b" | cut -d"/" -f3| cut -d"." -f1)
		echo 解压 $bh备份文件...
		sudo python3 $binner/imgextractor.py ./${bh}.win ./
		rm -rf ./${bh}.win
		sleep $sleeptime
	done
fi
fi
menu
}



# 打包Super
